<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Simulation Viewer</title>

  <!-- Optional: your unified CSS (keep if you have it) -->
  <!-- <link rel="stylesheet" href="assets/viewer.css"/> -->

  <!-- Plotly.js CDN -->
  <script src="https://cdn.plot.ly/plotly-3.1.0.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <style>
    /* ===== Minimal built-in styles so it looks good even without external CSS ===== */
    :root {
      --bg1: #0f1226; --bg2: #171a36; --bg3: #0b0f22;
      --grid-gap: 14px;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      color: #0b1220;
      background:
        radial-gradient(1200px 800px at 20% 10%, #20265b 0%, transparent 60%),
        radial-gradient(1000px 700px at 80% 20%, #103b5f 0%, transparent 60%),
        radial-gradient(1200px 900px at 50% 100%, #1b3266 0%, transparent 60%),
        linear-gradient(160deg, var(--bg1), var(--bg2) 40%, var(--bg3) 100%);
      transition: color .3s ease, background .3s ease;
    }
    html.dark, html.dark body { color: #e8eaf6; }

    .wrap { min-height: 100%; padding: 16px; max-width: 1500px; margin: 0 auto; }
    .toolbar { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    input[type="range"] { flex: 1; }

    .card {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.20);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: inherit;
    }
    html.dark .card {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.16);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      gap: var(--grid-gap);
      margin-top: 12px;
    }
    .card.plot { height: 360px; padding: 8px 8px 4px 8px; }
    #globe { height: 620px; }

    button {
      border: 0; border-radius: 12px; padding: 10px 16px;
      font-weight: 700; letter-spacing: .3px; cursor: pointer;
      color: #0b1220;
      background: linear-gradient(135deg, #7aa2ff, #6ae3ff);
      box-shadow: 0 8px 20px rgba(122,162,255,0.35);
      transition: transform .08s ease, filter .2s ease;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }

    .brand { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    .brand .logo { width: 50px; height: 50px; border-radius: 12px; object-fit: contain;
      background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    h1 { margin: 0; font-size: clamp(22px, 3vw, 32px); letter-spacing: .2px; }
    .lead { margin: 6px 0 14px 0; opacity: .9; line-height: 1.6; }
  </style>
</head>
<body>
<div class="wrap">
  <!-- Top controls -->
  <div class="toolbar card">
    <div class="brand">
      <img class="logo" src="assets/logo.jpg" alt="Logo">
      <h1>Simulation Viewer</h1>
    </div>
    <div style="flex:1"></div>
    <button id="play">‚èµ Play</button>
    <button id="pause">‚è∏ Pause</button>
    <label>Step
      <select id="step">
        <option value="1">1</option>
        <option value="10">10</option>
        <option value="50">50</option>
      </select>
    </label>
    <input id="slider" type="range" min="0" max="0" step="1" value="0"/>
    <button id="theme">üåì Theme</button>
  </div>

  <!-- Info -->
  <div id="info" class="card lead"></div>

  <!-- Globe -->
  <div id="globe" class="card"></div>

  <!-- Time series -->
  <div class="grid">
    <div id="Gini"       class="card plot"></div>
    <div id="HHI"      class="card plot"></div>
    <div id="liveness"  class="card plot"></div>
    <div id="CV"        class="card plot"></div>
    <div id="clusters"   class="card plot"></div>
    <div id="totaldist"  class="card plot"></div>
    <div id="avgnnd"     class="card plot"></div>
    <div id="nni"        class="card plot"></div>
    <div id="mev"        class="card plot"></div>
    <div id="attest"     class="card plot"></div>
    <div id="failed"     class="card plot"></div>
    <div id="proposal"   class="card plot"></div>
    <div id="relaydist"  class="card plot"></div>
  </div>
</div>

<script>
/* ============================
   URL + localStorage settings
   ============================ */
// Read settings from URL or localStorage (optional)
function readSettings() {
  const qs = new URLSearchParams(location.search);
  let ls = null;
  try { ls = JSON.parse(localStorage.getItem('app_settings') || 'null'); } catch (_) {}

  const base = {
    dataset: 'simulations/test/data.json',
    theme: 'auto',    // 'auto'|'light'|'dark'
    step: 1,
    autoplay: false,
    decimation: 5,    // border decimation
    density_radius: 0.2
  };
  const fromQS = {
    dataset: qs.get('dataset') || "data.json",
    theme: qs.get('theme') || undefined,
    step: qs.get('step') ? Number(qs.get('step')) : undefined,
    autoplay: qs.get('autoplay') ? (qs.get('autoplay') === 'true') : undefined,
    decimation: qs.get('decimation') ? Number(qs.get('decimation')) : undefined,
    density_radius: qs.get('radius') ? Number(qs.get('radius')) : undefined
  };
  return Object.assign(base, ls || {}, fromQS);
}

const SETTINGS = readSettings();
let dark = (SETTINGS.theme === 'dark')
        || (SETTINGS.theme === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);

/* ============================
   App State
   ============================ */
let DATA = null;
let WORLD_BORDER_TRACES = null;
let playing = !!SETTINGS.autoplay;
let slot = 0;
let stepSize = SETTINGS.step || 1;

/* ============================
   Theme helpers for Plotly
   ============================ */
// Unified Plotly-internal color/typography per theme
function plotlyTheme(isDark, title = '', yTitle = '') {
  if (isDark) {
    return {
      title,
      paper_bgcolor: '#1e1e1e',
      plot_bgcolor:  '#1e1e1e',
      font: { color: '#f0f0f0', size: 12 },
      colorway: ['#60a5fa','#fbbf24','#34d399','#a78bfa','#f472b6'],
      xaxis: { title: { text: 'Slot' }, gridcolor: '#444444', tickfont: { size: 11 } },
      yaxis: { title: { text: yTitle }, gridcolor: '#444444', tickfont: { size: 11 } }
    };
  } else {
    return {
      title,
      paper_bgcolor: 'rgba(255,255,255,0.7)',
      plot_bgcolor:  'rgba(255,255,255,0.7)',
      font: { color: '#0b1220', size: 12 },
      colorway: ['#3b82f6','#f59e0b','#10b981','#8b5cf6','#ef4444'],
      xaxis: { title: { text: 'Slot' }, gridcolor: '#e0e0e0', tickfont: { size: 11 } },
      yaxis: { title: { text: yTitle }, gridcolor: '#e0e0e0', tickfont: { size: 11 } }
    };
  }
}

/* ============================
   Utilities
   ============================ */
function linspace(a, b, n) {
  const step = (b - a) / (n - 1);
  return Array.from({length: n}, (_, i) => a + i * step);
}

function sphereGrid(phiArr, thetaArr) {
  const XS = [], YS = [], ZS = [];
  for (let i = 0; i < thetaArr.length; i++) {
    const rowX = [], rowY = [], rowZ = [];
    for (let j = 0; j < phiArr.length; j++) {
      const phi = phiArr[j], th = thetaArr[i];
      rowX.push(Math.sin(phi) * Math.cos(th));
      rowY.push(Math.sin(phi) * Math.sin(th));
      rowZ.push(Math.cos(phi));
    }
    XS.push(rowX); YS.push(rowY); ZS.push(rowZ);
  }
  return {XS, YS, ZS};
}

function latlonToXYZ(latDeg, lonDeg) {
  const phi = latDeg * Math.PI / 180;
  const theta = lonDeg * Math.PI / 180;
  return [Math.cos(phi) * Math.cos(theta), Math.cos(phi) * Math.sin(theta), Math.sin(phi)];
}

function decimate(coords, step) {
  if (step <= 1) return coords;
  const out = [];
  for (let i = 0; i < coords.length; i += step) out.push(coords[i]);
  if (coords.length && out[out.length - 1] !== coords[coords.length - 1]) out.push(coords[coords.length - 1]);
  return out;
}

function calculateDensity(points, radius = 0.2) {
    const n = points.length;
    const densities = new Array(n).fill(0);
    
    // We use the square of the radius to avoid calculating Math.sqrt() 
    // inside the loop, which significantly improves performance.
    const thresholdSq = radius * radius;

    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            // Calculate squared Euclidean distance between point i and point j
            const dx = points[i][0] - points[j][0];
            const dy = points[i][1] - points[j][1];
            const dz = points[i][2] - points[j][2];
            
            const distSq = dx * dx + dy * dy + dz * dz;

            // If the distance is within the threshold, increment density for both points
            if (distSq <= thresholdSq) {
                densities[i]++;
                densities[j]++;
            }
        }
    }
    return densities;
}

/* ============================
   Data loading
   ============================ */
async function loadGCPData() {
    const csvUrl = './data/gcp_regions.csv';

    return new Promise((resolve, reject) => {
        Papa.parse(csvUrl, {
            download: true,       // Enable file download
            header: true,         // Parse headers automatically
            skipEmptyLines: true, // Skip empty lines
            
            // Callback when parsing is finished
            complete: function(results) {
                const dataMap = new Map();

                results.data.forEach(row => {
                    const key = row.Region; 

                    if (key) {
                        dataMap.set(key, row);
                    }
                });

                resolve(dataMap);
            },
            
            error: function(err) {
                reject(err);
            }
        });
    });
}

async function loadData() {
  const resp = await fetch(SETTINGS.dataset, { cache: 'no-cache' });
  if (!resp.ok) throw new Error(`Failed to load ${SETTINGS.dataset}`);
  DATA = await resp.json();
  DATA.gcpData = await loadGCPData();
  document.getElementById('slider').max = Math.max(0, (DATA.n_slots || 1) - 1);
}

async function loadWorldBorders() {
  if (WORLD_BORDER_TRACES) return WORLD_BORDER_TRACES;
  const url = 'https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json';
  const resp = await fetch(url, { cache: 'force-cache' });
  if (!resp.ok) throw new Error('Failed to load countries.geo.json');
  const gj = await resp.json();

  const tracesLight = [], tracesDark = [];
  for (const feat of gj.features) {
    const geom = feat.geometry;
    if (!geom) continue;
    const polys = (geom.type === 'Polygon') ? [geom.coordinates]
                 : (geom.type === 'MultiPolygon') ? geom.coordinates : [];
    for (const poly of polys) {
      if (!poly.length) continue;
      const ring = decimate(poly[0], SETTINGS.decimation || 5); // [[lon,lat], ...]
      if (ring.length < 2) continue;
      const xs = [], ys = [], zs = [];
      for (const [lon, lat] of ring) {
        const [x, y, z] = latlonToXYZ(lat, lon);
        xs.push(x); ys.push(y); zs.push(z);
      }
      const base = { type: 'scatter3d', mode: 'lines', x: xs, y: ys, z: zs, hoverinfo: 'skip', showlegend: false };
      tracesLight.push({ ...base, line: { width: 1, color: '#888'  } });
      tracesDark .push({ ...base, line: { width: 1, color: '#aaaa' } });
    }
  }
  WORLD_BORDER_TRACES = { light: tracesLight, dark: tracesDark };
  return WORLD_BORDER_TRACES;
}

/* ============================
   Plot builders
   ============================ */
function drawGlobe(i) {
  const { slots, meta, sources } = DATA;
  const pts = [];
  for (const [region, count] of (slots[i] || [])) {
    const gcpInfo = DATA.gcpData.get(String(region));
    if (!gcpInfo) continue;

    const x = Number(gcpInfo.x), y = Number(gcpInfo.y), z = Number(gcpInfo.z);
    // Ignore invalid coordinates
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) continue;

    const n = Number(count) || 0;
    for (let k = 0; k < n; k++) pts.push([x, y, z]);
  }

  const rels = sources.map(source => {
    const gcpInfo = DATA.gcpData.get(source[1]);
    if (gcpInfo) {
      return [gcpInfo.x, gcpInfo.y, gcpInfo.z];
    } else {
      return [0, 0, 0]; // Default to origin if region not found
    }
  });
  const infoNames = sources.map(source => source[0]);

  const dens = calculateDensity(pts, SETTINGS.density_radius || 0.2);

  const validators = {
    type: 'scatter3d', mode: 'markers',
    x: pts.map(p => p[0]), y: pts.map(p => p[1]), z: pts.map(p => p[2]),
    marker: {
      size: 4,
      color: dens,
      colorscale: dark ? 'Plasma' : 'Viridis',
      showscale: true,
      colorbar: {
        title: 'Local Density', x: 1.15, len: 0.7,
        titlefont: { color: dark ? '#f0f0f0' : '#0b1220' },
        tickfont:  { color: dark ? '#f0f0f0' : '#0b1220' }
      }
    },
    name: 'Validators'
  };

  const phi = linspace(0, Math.PI, 40), theta = linspace(0, 2*Math.PI, 80);
  const {XS, YS, ZS} = sphereGrid(phi, theta);
  const sphere = {
    type: 'surface', x: XS, y: YS, z: ZS, showscale: false, opacity: 0.2,
    colorscale: [[0, dark ? '#444444' : 'lightblue'], [1, dark ? '#444444' : 'lightblue']],
    hoverinfo: 'skip', name: 'Earth'
  };

  const traces = [validators, sphere];

  if (rels.length) {
    traces.push({
      type: 'scatter3d', mode: 'markers+text',
      x: rels.map(r => r[0]), y: rels.map(r => r[1]), z: rels.map(r => r[2]),
      marker: { size: 10, color: 'red', symbol: 'diamond', line: { color: 'black', width: 1 } },
      text: infoNames, textposition: 'top center', name: 'Info Sources'
    });
  }

  const borders = dark ? WORLD_BORDER_TRACES.dark : WORLD_BORDER_TRACES.light;
  traces.push(...borders);

  const layout = {
    ...plotlyTheme(dark, 'Geo Tracker', ''),
    margin: { l: 15, r: 160, b: 20, t: 40 },
    scene: {
      xaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
               gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
      yaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
               gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
      zaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
               gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
      aspectmode: 'cube'
    },
    showlegend: true,
    legend: { x: 0.02, y: 0.98, bgcolor: dark ? 'rgba(45,45,45,0.7)' : 'rgba(255,255,255,0.7)' }
  };

  Plotly.newPlot('globe', traces, layout, { displaylogo: false, responsive: true });
}

function drawLine(divId, x, y, title, yTitle='') {
  const el = document.getElementById(divId);
  const h  = (el.clientHeight || 360) * 0.94;
  const layout = {
    ...plotlyTheme(dark, title, yTitle),
    height: h,
    margin: { l: 60, r: 20, t: 40, b: 40 },
    hovermode: 'x unified'
  };
  Plotly.newPlot(divId, [{
    type: 'scatter', mode: 'lines', x, y, line: { width: 2 }
  }], layout, { displaylogo: false, responsive: true, displayModeBar: false });
}

function drawRelayDist(i) {
  const el = document.getElementById('relaydist');
  const h  = (el.clientHeight || 360) * 0.94;
  const xs = Array.from({ length: i + 1 }, (_, k) => k);
  const series = DATA.metrics.info_avg_distance || [];
  const names  = DATA.sources.map(source => source[0]) || [];

  const traces = [];
  if (series.length) {
    const m = Math.max(...series.map(arr => (arr || []).length));
    for (let j = 0; j < m; j++) {
      const yy = [];
      for (let t = 0; t <= i; t++) {
        yy.push((series[t] && series[t][j] != null) ? series[t][j] : null);
      }
      traces.push({ type: 'scatter', mode: 'lines', x: xs, y: yy, name: names[j] || `Source ${j}`, line: { width: 2 } });
    }
  }

  const layout = {
    ...plotlyTheme(dark, 'Avg Distance to Info Sources', 'Avg. Distance'),
    height: h,
    margin: { l: 60, r: 20, t: 40, b: 40 },
    hovermode: 'x unified',
    legend: { orientation: 'h', yanchor: 'top', y: -0.25, xanchor: 'center', x: 0.5, font: { size: 11 } }
  };
  Plotly.newPlot('relaydist', traces, layout, { displaylogo: false, responsive: true, displayModeBar: false });
}

/* ============================
   Rendering orchestration
   ============================ */
function infoHTML(i) {
  const S = DATA.metrics;
  const num = (v, d=0) => (Number.isFinite(v) ? v : d);
  return `
    <div style="display:flex;flex-wrap:wrap;gap:18px">
      <span><b>Slot</b> ${i + 1}</span>
      <span>Clusters: ${S.clusters[i]}</span>
      <span>Total Distance: ${num(S.total_distance[i]).toFixed(4)}</span>
      <span>Avg NND: ${num(S.avg_nnd[i]).toFixed(4)}</span>
      <span>NNI: ${num(S.nni[i]).toFixed(4)}</span>
      <span>MEV: ${num(S.mev[i]).toFixed(4)}</span>
      <span>Attest: ${num(S.attestations[i]).toFixed(2)}%</span>
      <span>Proposal Time: ${num(S.proposal_times[i]).toFixed(2)} ms</span>
    </div>`;
}

function drawAll() {
  document.getElementById('info').innerHTML = infoHTML(slot);
  drawGlobe(slot);
  const xs = Array.from({ length: slot + 1 }, (_, k) => k);
  const S = DATA.metrics;
  drawLine('Gini',      xs, S.gini.slice(0, slot + 1), 'Gini Coefficient', 'Gini');
  drawLine('HHI',     xs, S.hhi.slice(0, slot + 1), 'HHI', 'HHI');
  drawLine('liveness',  xs, S.liveness.slice(0, slot + 1), 'Liveness Coefficient', 'Liveness Coefficient');
  drawLine('CV',        xs, S.profit_variance.slice(0, slot + 1), 'Coefficient of Variation', 'CV');
  drawLine('clusters',  xs, S.clusters.slice(0, slot + 1), 'Clusters', 'Clusters (#)');
  drawLine('totaldist', xs, S.total_distance.slice(0, slot + 1), 'Total Distance', 'Total Distance');
  drawLine('avgnnd',    xs, S.avg_nnd.slice(0, slot + 1), 'Avg NND', 'Avg NND');
  drawLine('nni',       xs, S.nni.slice(0, slot + 1), 'NNI', 'NNI');
  drawLine('mev',       xs, S.mev.slice(0, slot + 1), 'MEV Earned', 'Block Value');
  drawLine('attest',    xs, S.attestations.slice(0, slot + 1), 'Attestation Rate %', 'Attestation Rate (%)');
  drawLine('failed',    xs, (S.failed_block_proposals || []).slice(0, slot + 1), 'Failed Block Proposals', 'Failed Proposals (#)');
  drawLine('proposal',  xs, S.proposal_times.slice(0, slot + 1), 'Proposal Time (ms)', 'Proposal Time (ms)');
  drawRelayDist(slot);
  document.getElementById('slider').value = String(slot);
}

function tick() {
  if (playing) {
    const nSlots = DATA.n_slots || 1;
    slot = (slot + stepSize) % nSlots;
    drawAll();
  }
}

/* ============================
   Controls
   ============================ */
document.getElementById('play').onclick  = () => { playing = true;  };
document.getElementById('pause').onclick = () => { playing = false; };
document.getElementById('step').onchange = (e) => { stepSize = parseInt(e.target.value, 10) || 1; };
document.getElementById('theme').onclick = () => {
  dark = !dark;
  document.documentElement.classList.toggle('dark', dark);
  drawAll();
};
document.getElementById('slider').oninput = (e) => {
  slot = parseInt(e.target.value, 10) || 0;
  playing = false;
  drawAll();
};

/* ============================
   Boot
   ============================ */
(async function boot() {
  // Apply initial theme class
  document.documentElement.classList.toggle('dark', dark);

  await loadData();
  await loadWorldBorders();
  
  drawAll();

  // Autoplay if requested
  playing = !!SETTINGS.autoplay;
  stepSize = SETTINGS.step || 1;
  setInterval(tick, 500);
})().catch(err => {
  console.error(err);
  document.body.insertAdjacentHTML('beforeend', `<pre style="color:#ffb4b4;background:#2e1a1a;padding:10px;border-radius:8px">${String(err)}</pre>`);
});
</script>
</body>
</html>
